{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww18520\viewh15800\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 //LA Worksheet: Stacks and Queues\
//Problem 1\
bool isValid(string parens)\
\{\
	stack<char> openp;\
	for(int k=0; k<parens.size(); k++)\{\
		switch(parens[k])\
		\{\
		 case \'91(\'91:\
		 case \'91[\'91:\
			openp.push(parens[k]);\
			break;\
		 case \'91)\'92:\
		 case \'91]\'92:\
			if(openp.empty())\
				return false;\
			if(parens[k]==\'91)\'92&&openp.top()==\'91)\'92 || parens[k]==\'91[\'91&&openp.top()==\'91]\'92)\
				openp.pop();\
			else\
				return false;\
			break;\
		default:\
			break;\
		\}\
	\}\
\}\
//Problem 2\
void reverseQueue(queue<int> & Q)\{\
	if(Q.empty())\
		return;\
	stack<int> temp;\
	while(!Q.empty())\{\
		temp.push(Q.top());\
		Q.pop();\
	\}\
	while(!temp.empty())\{\
		Q.push(temp.top());\
		temp.pop();\
	\}	\
\}\
//Problem 5\
void findNextInts(const int sequence[], int results[], int n)\
\{\
	stack<int> temp;\
	for(int k=0; k<n; k++)\{\
		int i = k;\
		do\{\
			temp.push(sequence[k+1]);\
		while(!(temp.top()>sequence[k]));\
		results[k] = temp.top();\
	\}\
\}\
\
//Recursion practice\
void LL::deleteList(Node* p)\
\{\
	if(p==nullptr)\{\
		return;\
	\}\
	deleteList(p->next);\
	delete p;\
\}\
\
int getMax(int a[], int n)\
\{\
	if(n==1)\
		return a[0];\
	if(a[0]<a[n-1])\
		return getMax(a+1, n);\
	return getMax(a, n-1);\
\}\
\
\
\
\
\
\
}